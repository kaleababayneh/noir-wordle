{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":10227643159636439355,"abi":{"parameters":[{"name":"first_letter_commitment_hash","type":{"kind":"field"},"visibility":"public"},{"name":"second_letter_commitment_hash","type":{"kind":"field"},"visibility":"public"},{"name":"third_letter_commitment_hash","type":{"kind":"field"},"visibility":"public"},{"name":"fourth_letter_commitment_hash","type":{"kind":"field"},"visibility":"public"},{"name":"fifth_letter_commitment_hash","type":{"kind":"field"},"visibility":"public"},{"name":"first_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"second_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"third_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"fourth_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"fifth_letter_guess","type":{"kind":"field"},"visibility":"public"},{"name":"calculated_result","type":{"kind":"array","length":5,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"first_letter","type":{"kind":"field"},"visibility":"private"},{"name":"second_letter","type":{"kind":"field"},"visibility":"private"},{"name":"third_letter","type":{"kind":"field"},"visibility":"private"},{"name":"fourth_letter","type":{"kind":"field"},"visibility":"private"},{"name":"fifth_letter","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"3ZrNTiJREEbfpdcs7nd/q3iVycSgoiEhYBAnmRjfXTQ0ErxqODtcNn0/pMpTXcmB5+F2fv10f7VY3a0fh+mf52G5vpltF+vV7up5KO8vPT7MVm9Xj9vZZjtMm6fJMF/dDlNL+WUy3C2W82Fa9TL5dDSVuD+aVT+OWudobKr7s7Gl8P1htTZ+BjWPPxwOcfwUCrUcH/47GervL7H9/hKtV6Lltk94iMcl7gLeC3gOY8B08T1R6Nbo+RApOumK1IsomI0ZRbv8xsRulco6VOn1tDOpm4np0M3YyuV3Jver/Pj/p1xOO9NdEkp2+Ds5xsvvTHdPKKdyqNLDaWe6D159PHll6dMEGsj4+ZkYQKb/dHAbZyCGePqcjRFkEshkkCkgU0GmgYyBjJ+fSQFkAAcJcJAABwlwkAAHCXCQAAcJcJAABxlwkAEHGXCQAQcZcJABBxlwkAEHGXCQAQcFcFDK+bukVJAB+7SAfVpA3yroWwXzU8H8VDA/FcxPBfNTwfxUMD8VzE8FHDTAQQMcNMBBAxw0wEEDHDTAQQMcNMBBAxwY4MAABwY4MMCBAQ4McGCAAwMcGODA0/m7xDPIgH3qYJ866JuTvoH5UQgkJBKKJJRIKJNQIaFKQo2EjIQIESJEiBAhQoQIESJEiBAhQoQIESJEiBARCRHEYoloLBGPJSKyREyWiMrSF+7nez/5hfz5IZRIKJMQ6V5C3SPzRBSQiAMSkUAiFkhEA4l4IBERJGKCRFSQiAsSkUEiNkhEB6kQIgohohAiCiGiECIKIaIQIgohgnguEdElYrpEVJeI6xKRXargWze1QEJk5zayc4khElFEIo5IRBKJWCIRTSTiiUREkYgpElFFIq5IRBaJ2CIRXSTii0SEkYwQ4YQIJ0Q4IcIJEU6IcEKEEyKICRNRYSIuLBIXFokLi8SFxb43itF8DKVOyEjIQajvjX4K6dzQ7uJ6s1guF/dXx7+h3b38b7ZZzK6X8/3l3dPq5uju9v/DeGfMP2zWN/Pbp8387Z3e7+3e/hU=","file_map":{"61":{"source":"use poseidon::poseidon2::Poseidon2;\n\nfn main(\n\n    // commitment hashes for each letter\n    first_letter_commitment_hash: pub Field,\n    second_letter_commitment_hash: pub Field,\n    third_letter_commitment_hash: pub Field,\n    fourth_letter_commitment_hash: pub Field,\n    fifth_letter_commitment_hash: pub Field,\n    // guess result\n    first_letter_guess: pub Field,\n    second_letter_guess: pub Field,\n    third_letter_guess: pub Field,\n    fourth_letter_guess: pub Field,\n    fifth_letter_guess: pub Field,\n    // calculated final result\n    calculated_result: pub [u8; 5],\n    // private inputs\n    first_letter: Field,\n    second_letter: Field,\n    third_letter: Field,\n    fourth_letter: Field,\n    fifth_letter: Field,\n    salt: Field,\n    )\n     {\n\n    let first_letter_commitment = Poseidon2::hash([ salt, first_letter], 2);\n    assert(first_letter_commitment == first_letter_commitment_hash);\n    let second_letter_commitment = Poseidon2::hash([salt, second_letter], 2);\n    assert(second_letter_commitment == second_letter_commitment_hash);\n    let third_letter_commitment = Poseidon2::hash([salt, third_letter], 2);\n    assert(third_letter_commitment == third_letter_commitment_hash);\n    let fourth_letter_commitment = Poseidon2::hash([salt, fourth_letter], 2);\n    assert(fourth_letter_commitment == fourth_letter_commitment_hash);\n    let fifth_letter_commitment = Poseidon2::hash([salt, fifth_letter], 2);\n    assert(fifth_letter_commitment == fifth_letter_commitment_hash);\n\n    let mut correct_letters = [first_letter, second_letter, third_letter, fourth_letter, fifth_letter];\n    let guess_letters = [first_letter_guess, second_letter_guess, third_letter_guess, fourth_letter_guess, fifth_letter_guess];\n    let mut result_array = [0; 5];\n\n    for i in 0..5 {\n        if guess_letters[i] == correct_letters[i] {\n            result_array[i] = 2; // Correct letter\n        } else {\n            let mut found = false;\n            for j in 0..5 {\n                if correct_letters[j] == guess_letters[i] {\n                    found = true;\n                }\n            }\n            if found {\n                result_array[i] = 1; // Wrong position\n            } else {\n                result_array[i] = 0; // Incorrect letter\n            }\n        }\n    }\n\n    assert(calculated_result == result_array);\n}\n\n\n\n/*\n '0x1ba83d0d530a2a7784ac08f73f5507550c851552f170a6685068d3f78d29b920',\n  '0x1ee63ae23fba3b1af0e30baa89b79e00193935ea9b9543f62b78f0b6385efd70',\n  '0x1ee63ae23fba3b1af0e30baa89b79e00193935ea9b9543f62b78f0b6385efd70',\n  '0x0ed3294f4ba676f67296d5dcccdbe7dff01975032dda4c15eb3e732c77aa5cad',\n  '0x2bb35e499f8cb77c333df64bf07dbf52885c27b5c26eb83654dc956f44aeba00'\n*/\n#[test]\nfn test_main() {\n    println(\"test\");\n    let salt = Field::from(0);\n    let first_letter_commitment_hash: Field = 0x1ba83d0d530a2a7784ac08f73f5507550c851552f170a6685068d3f78d29b920;\n    let first_letter: Field = Field::from(97);\n    let second_letter_commitment_hash: Field = 0x1ee63ae23fba3b1af0e30baa89b79e00193935ea9b9543f62b78f0b6385efd70;\n    let second_letter: Field = Field::from(112);\n    let third_letter_commitment_hash: Field = 0x1ee63ae23fba3b1af0e30baa89b79e00193935ea9b9543f62b78f0b6385efd70;\n    let third_letter: Field = Field::from(112);\n    let fourth_letter_commitment_hash: Field = 0x0ed3294f4ba676f67296d5dcccdbe7dff01975032dda4c15eb3e732c77aa5cad;\n    let fourth_letter: Field = Field::from(108);\n    let fifth_letter_commitment_hash: Field = 0x2bb35e499f8cb77c333df64bf07dbf52885c27b5c26eb83654dc956f44aeba00;\n    let fifth_letter: Field = Field::from(101);\n\n    let first_letter_guess: Field = Field::from(97); // a\n    let second_letter_guess: Field = Field::from(112); // p\n    let third_letter_guess: Field = Field::from(112); // p\n    let fourth_letter_guess: Field = Field::from(97); // a\n    let fifth_letter_guess: Field = Field::from(111); // o\n\n    let result: [u8; 5] = [2, 2, 2, 1, 0]; \n   \n\n\n   main(\n        first_letter_commitment_hash, \n        second_letter_commitment_hash, \n        third_letter_commitment_hash,\n        fourth_letter_commitment_hash,\n        fifth_letter_commitment_hash,\n        \n        first_letter_guess, \n        second_letter_guess, \n        third_letter_guess, \n        fourth_letter_guess, \n        fifth_letter_guess, \n\n        result, \n\n        first_letter, \n        second_letter, \n        third_letter, \n        fourth_letter, \n        fifth_letter, \n\n        salt\n    );\n}","path":"/Users/kaleab/Documents/noir-wordle/circuits/src/main.nr"},"68":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/kaleab/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}